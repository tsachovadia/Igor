import json
import os
from datetime import datetime


def generate_json_database(filesystem_data, applications_data, output_path="database.json"):
    """
    יוצר קובץ JSON מקיף עם כל המידע שנאסף.
    """
    database = {
        "scan_timestamp": datetime.now().isoformat(),
        "filesystem": filesystem_data,
        "applications": applications_data,
        "metadata": {
            "total_applications": len(applications_data),
            "total_files_scanned": count_files_recursive(filesystem_data),
            "scan_root": filesystem_data.get('path', 'Unknown')
        }
    }
    
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(database, f, indent=2, ensure_ascii=False)
    
    print(f"JSON database saved to: {output_path}")
    return output_path


def generate_interactive_map(filesystem_data, output_path="interactive_map.html"):
    """
    יוצר מפת חשיבה אינטראקטיבית בפורמט HTML.
    """
    # המרת המבנה לפורמט Markdown מוזח
    markdown_content = convert_to_markdown_hierarchy(filesystem_data, max_depth=4)
    
    # תבנית HTML עם markmap
    html_template = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Igor System Map - Interactive</title>
    <script src="https://unpkg.com/d3@6"></script>
    <script src="https://unpkg.com/markmap-view@0.2.7"></script>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; }}
        #mindmap {{ width: 100%; height: 600px; border: 1px solid #ccc; }}
        .header {{ text-align: center; margin-bottom: 20px; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Igor System Organization Map</h1>
        <p>Interactive visualization of your system structure</p>
        <p><em>Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</em></p>
    </div>
    <div id="mindmap"></div>
    <script>
        const markdown = `{markdown_content}`;
        const {{ markmap }} = window;
        const {{ transform, Markmap }} = markmap;
        const transformer = transform();
        const {{ root, features }} = transformer.transform(markdown);
        const mm = Markmap.create('#mindmap', null, root);
    </script>
</body>
</html>"""

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_template)
    
    print(f"Interactive map saved to: {output_path}")
    return output_path


def generate_editable_map(filesystem_data, output_path="editable_map.md"):
    """
    יוצר קובץ Markdown מוזח שניתן לעריכה.
    """
    markdown_content = convert_to_markdown_hierarchy(filesystem_data, max_depth=5)
    
    header = f"""# Igor System Organization Map (Editable)

Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

This file can be opened in any mind-mapping tool that supports Markdown format.

---

"""
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header + markdown_content)
    
    print(f"Editable map saved to: {output_path}")
    return output_path


def generate_markdown_report(filesystem_data, applications_data, output_path="system_report.md"):
    """
    יוצר דוח מרכזי בפורמט Markdown עם כל המידע.
    """
    # חישוב סטטיסטיקות
    total_files = count_files_recursive(filesystem_data)
    total_size = calculate_total_size(filesystem_data)
    
    # יצירת תרשים Mermaid
    mermaid_chart = generate_mermaid_hierarchy(filesystem_data, max_depth=3)
    
    # יצירת טבלת תוכנות
    apps_table = generate_applications_table(applications_data)
    
    report_content = f"""# Igor System Audit Report

**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary

| Metric | Value |
|--------|-------|
| Total Files Scanned | {total_files:,} |
| Total Size | {format_size(total_size)} |
| Total Applications | {len(applications_data)} |
| Scan Root | `{filesystem_data.get('path', 'Unknown')}` |

## System Structure Overview

The following diagram shows the top-level structure of your system:

```mermaid
{mermaid_chart}
```

## Applications & Tools

{apps_table}

## PARA Method Recommendations

Based on the scan results, here are recommendations for organizing your digital environment using the PARA method:

### Projects (Active work requiring attention)
- Look for folders with recent modifications in Documents, Desktop
- Consider consolidating scattered project files

### Areas (Ongoing responsibilities to maintain)
- System maintenance folders (Applications, Library settings)
- Regular backup and archival processes

### Resources (Future reference materials)
- Archive old project folders
- Organize reference materials in dedicated structure

### Archive (Inactive items from the other categories)
- Move completed projects to archive structure
- Clean up unused applications and old files

---

*Report generated by Igor Organizer - PARA Method System Analysis*
"""

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(report_content)
    
    print(f"Markdown report saved to: {output_path}")
    return output_path


def convert_to_markdown_hierarchy(node, depth=0, max_depth=4):
    """
    ממיר מבנה קבצים למבנה Markdown מוזח.
    """
    if depth > max_depth:
        return ""
    
    indent = "  " * depth
    markdown = f"{indent}- {node['name']}"
    
    if node['type'] == 'file':
        size_str = format_size(node['size'])
        markdown += f" ({size_str})"
    
    markdown += "\\n"
    
    if 'children' in node and depth < max_depth:
        # מגביל למספר ילדים כדי שלא יהיה עמוס מדי
        children = sorted(node['children'], key=lambda x: (x['type'] == 'file', x['name']))[:10]
        for child in children:
            markdown += convert_to_markdown_hierarchy(child, depth + 1, max_depth)
        
        if len(node['children']) > 10:
            markdown += f"{indent}  - ... ({len(node['children']) - 10} more items)\\n"
    
    return markdown


def generate_mermaid_hierarchy(node, depth=0, max_depth=3):
    """
    יוצר תרשים Mermaid מהמבנה.
    """
    if depth == 0:
        chart = "graph TD\\n"
        node_id = "root"
        chart += f'    {node_id}["{node["name"]}"]\\n'
    else:
        chart = ""
        node_id = f"node_{depth}_{hash(node['name']) % 1000}"
    
    if 'children' in node and depth < max_depth:
        # מגביל ל-5 ילדים ראשונים כדי שהתרשים לא יהיה עמוס
        children = sorted(node['children'], key=lambda x: (x['type'] == 'file', x['name']))[:5]
        for i, child in enumerate(children):
            child_id = f"node_{depth+1}_{i}_{hash(child['name']) % 1000}"
            chart += f'    {node_id} --> {child_id}["{child["name"]}"]\\n'
            if depth + 1 < max_depth and 'children' in child:
                chart += generate_mermaid_hierarchy(child, depth + 1, max_depth).replace("graph TD\\n", "")
    
    return chart


def generate_applications_table(applications_data):
    """
    יוצר טבלת Markdown של התוכנות.
    """
    if not applications_data:
        return "No applications found."
    
    table = """| Application | Version | Type | Last Modified |
|-------------|---------|------|---------------|
"""
    
    for app in applications_data[:50]:  # מגביל ל-50 הראשונות
        name = app['name'][:30] + "..." if len(app['name']) > 30 else app['name']
        version = app['version'][:15] + "..." if len(str(app['version'])) > 15 else app['version']
        app_type = app['type']
        last_mod = app['last_modified'][:10] if len(str(app['last_modified'])) > 10 else app['last_modified']
        
        table += f"| {name} | {version} | {app_type} | {last_mod} |\\n"
    
    if len(applications_data) > 50:
        table += f"\\n*... and {len(applications_data) - 50} more applications*\\n"
    
    return table


def count_files_recursive(node):
    """
    סופר קבצים באופן רקורסיבי.
    """
    if node['type'] == 'file':
        return 1
    
    count = 0
    if 'children' in node:
        for child in node['children']:
            count += count_files_recursive(child)
    
    return count


def calculate_total_size(node):
    """
    מחשב גודל כולל באופן רקורסיבי.
    """
    total = node.get('size', 0)
    
    if 'children' in node:
        for child in node['children']:
            total += calculate_total_size(child)
    
    return total


def format_size(size_bytes):
    """
    ממיר בתים לפורמט קריא.
    """
    if size_bytes == 0:
        return "0 B"
    
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024
    
    return f"{size_bytes:.1f} PB" 